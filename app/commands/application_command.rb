class ApplicationCommand
  include ActiveModel::Model

  # Application Command
  #
  # CQRS and EventSourcing for Rails
  #
  # This abstraction allows us to integrate more seamlessly with smart contracts
  # that run on the Ethereum Blockchain.  (referred to as the Ethereum API)
  #
  # In this scheme, the core data abstraction is the EventStore, an append-only
  # datastructure implemented as a PostgresQL Table.  Each record in the
  # EventStore is called an EventLine (see `models/event_line`)
  #
  # How it works:
  # - Commands operate like AR models (using `ActiveModel`)
  # - Commands are composed of sub-objects (standard Rails models)
  # - Commands can save an event to the EventStore
  # - Commands can be initialized from the EventStore
  # - Commands can generate `projections` (DDD parlance...)
  #
  # - use for forms - edit and create commands - anything that updates the DB
  #   - single-model updates
  #   - multi-model transactions
  # - creates event store
  #   - events are the ultimate source of truth
  #   - events are signed as in a merkle chain
  #   - events can be generated by commands OR come from Solidity contracts
  #   - events can have one or more projections
  #   - events can be replayed

  # - using commands from controllers
  #    `Command.new(params).project`
  # - using commands to replay events
  #    `Command.from_event(event).project`

  # form handling inspired by
  # http://blog.sundaycoding.com/blog/2016/01/08/contextual-validations-with-form-objects

  # ----- instance methods
  def add_event(key, event)
    raise "EMPTY KEY" if key.nil? || key.blank?
    raise "DUPLICATE KEY (#{key})" if state[:events][key]
    state[:events][key] = event
    self.define_singleton_method("#{key.to_s}_event".to_sym) do
      state[:events][key]
    end
    self.define_singleton_method("#{key.to_s}_new".to_sym) do
      state[:events][key].new_object
    end
  end

  def events
    state[:events]
  end

  def set(name, object)
    varname = "@#{name.to_s}"
    self.instance_variable_set varname, object
  end

  # ----- persistence methods -----

  def save
    raise "NOT ALLOWED - USE #project"
  end

  def project
    if valid?
      ActiveRecord::Base.transaction do
        events.each do |key, event|
          varname = "@#{key.to_s}"
          self.define_singleton_method(key) { eval varname }
          object = event.ev_cast
          self.instance_variable_set varname, object
          raise ActiveRecord::Rollback unless object.valid?
        end
      end
      self
    else
      nil
    end
  end

  # ----- validation predicates

  # validations can live in the Command or the Sub-Object (or both!)
  def valid?
    if super && events.values.map(&:valid?).all?
      true
    else
      events.values.each do |obj|
        obj.valid?
        obj.errors.each do |field, error|
          errors.add(field, error)
        end
      end
      false
    end
  end

  def invalid?
    !valid?
  end

  def state
    @state ||= {}
    @state[:events] ||= {}
    @state
  end

  def state=(val)
    @state = val
  end

  private

  def cmd_uuid
    @cmd_uuid ||= SecureRandom.uuid
  end

  def cmd_type
    @cmd_type ||= self.class.name
  end

  def cmd_opts(opts = {})
    base_opts = opts.stringify_keys.slice("note", "tags")
    {"cmd_type" => cmd_type, "cmd_uuid" => cmd_uuid}.merge(base_opts)
  end
end
